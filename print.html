<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Alan Language</title>

    <!-- Custom HTML head -->
    

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="The Alan Programming Language">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />
    <meta property="og:title" content="Alan Language">
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://alan-lang.org/alan-logo.png">
    <meta property="og:description" content="The Alan Programming Language">
    <meta property="og:url" content="https://alan-lang.org">
    <meta name="twitter:card" content="summary" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
        <link rel="stylesheet" href="css/solarized-light-hljs.css">
    
        <link rel="stylesheet" href="css/solarized-dark-hljs.css">
    
        <link rel="stylesheet" href="css/override.css">
    

</head>

<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "solarized-dark" : "solarized-light";
    var html = document.querySelector('html');
    html.classList.add(default_theme);
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
  try {
    var sidebar = localStorage.getItem('mdbook-sidebar');

    if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
      localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
    }
  } catch (e) { }
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
  var html = document.querySelector('html');
  var sidebar;
  html.classList.remove('sidebar-visible');
  if (document.body.clientWidth >= 1080 && "" !== "Alan Language") {
    try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { console.error(e) }
    sidebar = sidebar || 'visible';
  } else {
    sidebar = 'hidden'
  }
  html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
  <div class="sidebar-scrollbox">
    <ol class="chapter"><li class="chapter-item expanded affix "><a href="homepage.html">Alan Language</a></li><li class="chapter-item expanded affix "><a href="blog.html">Blog</a></li><li class="chapter-item expanded "><a href="why_alan.html"><strong aria-hidden="true">1.</strong> Why we created Alan</a></li><li class="chapter-item expanded "><a href="alan_overview.html"><strong aria-hidden="true">2.</strong> An Overview of Alan</a></li><li class="chapter-item expanded "><a href="the-turing-completeness-problem.html"><strong aria-hidden="true">3.</strong> The Turing-Completeness Problem</a></li></ol>
  </div>
  <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
      
      <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
          <div id="left-menu" class="left-buttons">
            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
              <i class="fa fa-bars"></i>
            </button>
            
              <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                <i class="fa fa-search"></i>
              </button>
            
          </div>

          <h1 class="menu-title">Alan Language</h1>

          <div class="right-buttons">
            <a id="dyn-navigation">
            </a>
            <a href="https://docs.alan-lang.org" title="Documentation">
              <i>Docs</i>
            </a>
            <a href="https://github.com/alantech/alan" title="Documentation">
              <i>Github</i>
            </a>
          </div>
        </div>
        
          <div id="search-wrapper" class="hidden">
            <form id="searchbar-outer" class="searchbar-outer">
              <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
            </form>
            <div id="searchresults-outer" class="searchresults-outer hidden">
              <div id="searchresults-header" class="searchresults-header"></div>
              <ul id="searchresults">
              </ul>
            </div>
          </div>
        

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
          document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
          document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
          Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
            link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
          });
        </script>
        <div id="content" class="content">
            <main>
                <p> </p>
<center>
  <img src="alan-logo.png" alt="drawing" width="180"/>
  <h1 style="color: var(--title);">The Alan Programming Language</h1>
</center>
<div class="row">
  <div class="column">
    <center>
      <img src="implicit-parallel.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">Distributed computing without parallel programming</h3>
    Alan recognizes and exploits opportunities for parallelization without parallel programming (threads, channels, futures, locks, etc.)
  </div>
  <div class="column">
    <center>
      <img src="runtime-safety.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">No race conditions and fewer runtime errors</h3>
    Deadlocks, livelocks, undefined variables, divide-by-zero, integer under/overflow, array out-of-bounds access, etc, are not possible in Alan.
  </div>
  <div class="column">
    <center>
      <img src="permissions.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">Granular third party permissions</h3>
    Alan's module resolution mechanism allows you to prevent third party dependencies from having access to standard libraries that they should not have access to.
  </div>
</div>
<p> </p>
<h2><a class="header" href="#try-alan" id="try-alan">Try Alan</a></h2>
<table id="playground-table">
<tr>
<th></th>
<th></th>
</tr>
<tr>
<td>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">import @std/app

on app.start {
  app.print(&quot;Hello, World!&quot;);
  emit app.exit 0;
}
</code></pre></pre>
</td>
</table>
<p><a id="run-playground" onclick="analytics.track('RunPlayground');" class="cta-button">Run this code</a></p>
<h2><a class="header" href="#compare-alan" id="compare-alan">Compare Alan</a></h2>
<center>
  <div class="tabs-container">
    <div class="tabs effect">        
      <input type="radio" id="tab-1" name="tab-effect" checked="checked">
      <span class="tab-indicator"></span>
      <input type="radio" id="tab-2" name="tab-effect">
      <span class="tab-indicator"></span>
      <input type="radio" id="tab-3" name="tab-effect">
      <span class="tab-indicator"></span>
      <!-- tab-content -->
      <div class="tab-content">
        <section id="tab-go">
          <pre class="code-border alan"><code class="language language-alan">
  /* ALAN runs array operations in parallel
  utilizing all the available CPU cores
  if the array is large enough
  and the inner function given to it is pure. */
  fn sumMaybeConcurrent(nums: Array&lt;int&gt;): int {
    return nums.reducePar(fn (accum: int, val: int): int = accum + val);
  }
          </code></pre>
          <pre class="code-border"><code class="language language-golang">
  /* GOLANG
  https://play.golang.org/p/yB7gR3r09ZU
  */
  func sum(nums []int, out chan int) {
    var sum int
    for _, num := range nums {
      sum += num
    }
    out <- sum
  }
  func sumConcurrent(numbers []int) int {
    threads := runtime.NumCPU() - 1
    out := make(chan int)
    stride := len(numbers) / threads
    for i := 0; i < threads; i++ {
      go sum(numbers[i*stride:(i*stride)+stride], out)
    }
    go sum(numbers[threads*stride:len(numbers)], out)
    var s int
    for i := 0; i <= threads; i++ {
      s += <-out
    }
    return s
  }
          </code></pre>
        </section>
        <section id="tab-java">
        <pre class="code-border alan"><code class="language language-alan">
  /* ALAN */
  fn fetchAndSum(urls: Array&lt;string&gt;): int {
    return urls
      .map(fn (url: string): int {
        const website = http.get(url) || http.none;
        return toString(website.body).length();
      })
      .reducePar(fn (accum: int, val: int): int = accum + val);
  }
        </code></pre>
        <pre class="code-border"><code class="language language-java">
  /* JAVA */
  Integer fetchAndSum(String...urls) {
    var sum = CompletableFuture.completedFuture(0);
    try {
      return Stream
            .of(urls)
            .parallel()
            .map(url -> httpClient
                .sendAsync(request(url), BodyHandlers.ofString())
                .thenApply(HttpResponse::body)
                .thenApply(String::length))
            .reduce(sum, (prev, curr) -> prev
                .thenCombine(curr, (p, c) -> p + c))
            .get();
    } catch(Exception e){
      System.out.println(e.toString());
      return 0;
    }
  }
        </code></pre>
        </section>
        <section id="tab-js">
                  <pre class="code-border alan"><code class="language language-alan">
  /* ALAN automatically executes IO concurrently when possible */
  fn getValidUids() {
    const authUids = Auth.getAllUsers().map(fn (u: AuthUser): int = u.id);
    const dbUids = Store.getAllUsers().map(fn (u: User): int = u.uid);
    const crmUids = Crm.getAllUsers().map(fn (u: CrmUser): int = u.uid);
    return authUids.filter(fn (v: int): bool = dbUids.has(v) && crmUids.has(v));
  }
        </code></pre>
        <pre class="code-border"><code class="language language-javascript">
  /* NODE.JS equivalent */
  async function getValidUids() {
    const [authUsers, dbUsers, crmUsers] = await Promise.all([
      Auth.getAll(),
      Store.getAllUsers(),
      Crm.getAllUsers()
    ]);
    const authUids = authUsers.map(u => u['id']);
    const dbUids = dbUsers.map(u => u['uid']);
    const crmUids = crmUsers.map(u => u['uid']);
    return authUids.filter(v => dbUids.includes(v) && crmUids.includes(v))
  }
        </code></pre>
        </section>
      </div>
    </div>
  </div>
</center>
<p> </p>
<center>
  <a href="https://github.com/alantech/alan" onclick="analytics.track('DownloadCTA');" class="cta-button">Get Started</a>
</center>
<h2><a class="header" href="#contact" id="contact">Contact</a></h2>
<p>Please reach out on <a href="https://discord.gg/XatB9we">Discord</a>, <a href="https://www.reddit.com/r/alanlang">Reddit</a> or email us at hello at alantechnologies dot com.</p>
<h1><a class="header" href="#blog" id="blog">Blog</a></h1>
<ul>
<li><a href="./why_alan.html">Why we created Alan</a> | 2020-08-14</li>
<li><a href="./alan_overview.html">An Overview of Alan</a> | 2020-08-16</li>
<li><a href="./the-turing-completeness-problem.html">The Turing-Completeness Problem</a> | 2020-11-04</li>
</ul>
<h1><a class="header" href="#why-we-created-alan" id="why-we-created-alan">Why we created Alan</a></h1>
<p><strong>14 August 2020 | David Ellis, Luis F. De Pombo</strong></p>
<p>We created a programming language to be able to write concurrent algorithms and business logic without having to explicitly program how it should be parallelized. Alan makes people more productive by managing IO and computational parallelism for them in the same way languages from the 90s like Java and Python made people more productive, when compared to C or C++, by managing memory for them.</p>
<p>Why the name? Alan is named in honor of Alan Turing. We find great inspiration in the magnitude of his intellectual contributions.</p>
<h4><a class="header" href="#implicit-parallelization-over-arrays-events-and-io" id="implicit-parallelization-over-arrays-events-and-io">Implicit parallelization over arrays, events and IO</a></h4>
<p>Alan is <a href="./alan_overview.html#implicitly-parallel">implicitly parallel</a> because its compiler and runtime exploits opportunities for parallelization across the computing resources available without being told to do so. We have <a href="./alan_overview.html#parallel-computation-and-the-problem-of-turing-completeness">constrained the language a bit</a> to provide better opportunities to do this. This results in nimbler codebases than those built with languages or frameworks that use parallel programming constructs such as threads, actors, channels, locks, futures, promises etc.</p>
<h4><a class="header" href="#no-race-conditions-and-fewer-runtime-errors" id="no-race-conditions-and-fewer-runtime-errors">No race conditions and fewer runtime errors</a></h4>
<p>Deadlocks, livelocks, undefined variables, divide-by-zero, integer under/overflow, array out-of-bounds access, etc, are not possible in Alan. Only out-of-memory errors persist, but they are impossible to avoid. This makes Alan codebases easier to maintain and develop in because <a href="./alan_overview.html#statically-compiled-benefits-and-compile-time-safety">runtime errors are nearly always caught at compile time</a>.</p>
<h4><a class="header" href="#granular-third-party-permissions" id="granular-third-party-permissions">Granular third party permissions</a></h4>
<p>Alan's module resolution mechanism, with mocking built-in, allows you to <a href="./alan_overview.html#third-party-module-permission-system">prevent specific third-party dependencies from having access to  specific standard libraries</a> that they should not have access to.</p>
<h4><a class="header" href="#no-gc-pauses" id="no-gc-pauses">No GC pauses</a></h4>
<p>Alan’s runtime manages memory allocation, access, and deallocation for you like Java, Python, or Javascript. However, Alan’s static event system and <a href="./alan_overview.html#memory-management">automatic event-oriented memory model</a> does so without garbage collector pauses.</p>
<h4><a class="header" href="#join-us" id="join-us">Join Us</a></h4>
<p>There is still a ways to go for Alan to become a worthy abstraction to automatically parallelize software, but if you are moved by the vision please try it out, give us your feedback and help us shape it.</p>
<h1><a class="header" href="#an-overview-of-alan" id="an-overview-of-alan">An Overview of Alan</a></h1>
<p><strong>16 August 2020 | Luis F. De Pombo, David Ellis</strong></p>
<p>Programming languages are useful not only for what they allow, but what they prevent. That is the key separation between a language and a framework. For good or for ill, a framework can be sidestepped by its users while a language can't.</p>
<p>This overview of Alan will emphasize just as much what it prevents you from doing as what it provides to you. We believe our blend of features and omissions is what general purpose computing needs in the multicore era.</p>
<h2><a class="header" href="#what-alan-provides" id="what-alan-provides">What Alan Provides</a></h2>
<p>Alan is a natively-parallel, statically-compiled, type-inferred, evented language with a familiar syntax and many compile-time and run-time safety guarantees.</p>
<h3><a class="header" href="#implicitly-parallel" id="implicitly-parallel">Implicitly Parallel</a></h3>
<p>Alan's compiler and runtime automatically recognizes and exploits the parallelism inherent to the computations expressed by some of the language's constructs and automatically managing IO and compute threadpools.</p>
<p><strong>Parallelism over events</strong> is accomplished via the static event system baked into the language:</p>
<pre><code class="language-alan">on http.connection fn (conn: http.Connection) {
  let res: http.Request = conn.res;
  res.body(&quot;Hello, World!&quot;).status(200).send();
}
</code></pre>
<p>Independent connections to the HTTP server are scheduled onto the event loop and the compute threadpool pulls them from the queue and executes them in parallel.</p>
<p><strong>Parallelism over arrays</strong> if the array is large enough and the inner function given to it is pure, each of these steps will run in parallel, utilizing all of the CPU cores on the machine:</p>
<pre><code class="language-alan">someLargeArray
  .filter(fn (val: SomeType): bool = val &gt; someDefaultVal)
  .map(fn (val: SomeType): float64 = val.innerNumber * 3.14159)
  .reducePar(fn (acc: float64, cur: float64): float64 = acc + cur)
  .print();
</code></pre>
<p>The developer needs to know when to use <code>reducePar</code> vs <code>reduce</code>. It would be great to have auto-parallelism on <code>reduce</code> like every other array operation, but that would require the compiler to be able to prove commutative/associative properties on closures. </p>
<p><strong>IO Concurrency</strong> is accomplished by eagerly running IO-bound opcodes within the runtime based on the dependency graph of statements:</p>
<pre><code class="language-alan">const data: Result&lt;string&gt; = http.get(&quot;https://someurl.com/csvfile.csv&quot;);
const datacsv: Array&lt;Array&lt;int64&gt;&gt; = (data || '').split('\n').map(fn (row: string): Array&lt;int64&gt; = row.split(',').map(toInt64));
const data2: Result&lt;string&gt;  = http.get(&quot;https://someotherdatasource.org/othercsvfile.csv&quot;);
const data2csv: Array&lt;Array&lt;int64&gt;&gt; = (data2 || '').split('\n').map(fn (row: string): Array&lt;int64&gt; = row.split(',').map(toInt64));
// Compare the data...
</code></pre>
<p>The Alan runtime will see that the two URL fetches do not depend on each other and can run in parallel, so they will be hoisted to the top of the function call, executed in parallel, and the function execution continues after they return, minimizing overall latency and scheduling costs.</p>
<h3><a class="header" href="#statically-compiled-benefits-and-compile-time-safety" id="statically-compiled-benefits-and-compile-time-safety">Statically Compiled Benefits and Compile-Time Safety</a></h3>
<p>Alan has a multi-stage compiler with two compile targets: It's own native AGC bytecode format to be run by its native runtime, and Javascript to allow running in Node.js or the browser.</p>
<p>This will make it possible to make full-stack web applications in Alan that can also be ejected to Javascript if you no longer wish to develop in Alan. (&quot;Will&quot; because the cross-compiler's primary focus has been on correctness, not legibility, of the generated Javascript, but that will improve over time. Also because Alan bindings to Web APIs have not yet been written.)</p>
<p>Being statically compiled brings lots of benefits (and a few drawbacks) to the table. Primarily, the compiler can spot and prevent many classes of trivial errors from getting into production, but at the expense of requiring a compilation step between checking the changes made to your code.</p>
<p>However, Alan takes the safety guarantees to a higher level:</p>
<ul>
<li><strong>No <code>undefined</code> variables, ever:</strong> In Alan, <code>let</code> or <code>const</code> declared variables <em>must</em> be given an initial value. Potentially missing data can be represented with a <code>Maybe&lt;T&gt;</code> type, but then the compiler will force checking for the presence of actual data or providing a default value if not present. Downstream logic can be assured that the type they are working with is real.</li>
<li><strong>Most runtime errors impossible:</strong> Out of memory errors are impossible to avoid, but other issues, such as divide-by-zero, integer under/overflow, array out-of-bounds accesses, etc, are not possible in Alan. Actions that could have runtime errored in other languages are converted into <code>Result&lt;T&gt;</code> types that have to be checked for an error condition and/or have a default value provided instead. (The default set of math operators return <code>Result</code>-wrapped values and can accept such values in place of raw integers or floats, but there is also a second set of math operators copying Rust's <a href="https://doc.rust-lang.org/std/intrinsics/fn.saturating_add.html">saturating arithmetic</a> mechanism that always works on raw integers or floats, and will produce predictable but potentially unexpected values when a runtime error would have been reached, otherwise.)</li>
<li><strong>Deadlocks, Livelocks, and other multithreading issues impossible:</strong> There is no explicit multithreading in Alan. The compiler determines what code you have written is safely parallelizable does this for you. As Alan's compiler and runtime become more intelligent, more code will become parallelized, but with most array operations already being parallelizable as well as all events, the majority of the parallelization possibilities are already covered.</li>
<li><strong>No shared, mutable state:</strong> Alan defers all such responsibility to databases and caching systems that have had decades of work behind them and many tradeoffs between different mechanisms. We may revisit this if we can bring something to the table here with a significant advantage and minimal downsides in the future, however.</li>
</ul>
<h3><a class="header" href="#third-party-module-permission-system" id="third-party-module-permission-system">Third-Party Module Permission System</a></h3>
<p>Beyond direct code and syntax safety guarantees, Alan also provides safety mechanisms on third-party modules. Alan's module resolution mechanism includes built-in support for <a href="https://docs.alan-lang.org/module_testing.html">defining mocks</a> and, more importantly, <a href="https://docs.alan-lang.org/module_mutation.html">defining mutations</a> of existing modules. This mechanism can be used to deny third party libraries access to parts of the standard library you are not comfortable with. By simply creating a <code>modules</code> directory within the third-party dependency and then defining an <code>std/app.ln</code> file that re-exports non-functional versions of the types, functions, and events of the original standard library, you can prevent that library from being able to use standard library features you would not expect them to have access to. For instance, if you have imported a very popular utility library for, say, curve fitting. You would not expect it to want to have access to your filesystem or creating a child process, so you could inject nonfunctional mocks of <code>@std/fs</code> and <code>@std/cmd</code>.</p>
<p>This causes the third party code to be compiled without the opcodes it needs to access that functionality at all, providing a defense-in-depth that can be applied along with standard auditing, package signing, and CVE reporting on open source projects. Making this behavior easy-to-use automatically through the package management system is a project goal that will provide users of Alan a layer of security no other project approaches.</p>
<h3><a class="header" href="#memory-management" id="memory-management">Memory Management</a></h3>
<p>Most safety in Alan is tackled at compile-time, where it belongs, so you can write code that handles it and it doesn't cause an issue in production. But one major piece that is handled by the runtime for you is memory allocation, access, and deallocation, and Alan does so without GC pauses.</p>
<p>Languages that handle memory management for you, like Java or Python, tend to be more productive languages to work in, with the cost of a Garbage Collector periodically pausing your code to find and clean up unused memory. Languages without that, like C or C++, require extra cognitive overhead to manage it, but tend to be faster and have a lower memory footprint.</p>
<p>In Alan, memory is allocated at the beginning of an event handler's run for all &quot;stack-like&quot; variables (basic constants and variables in the handler and all functions it uses) while &quot;heap-like&quot; variables (arrays and user types) are allocated as needed to the size needed at runtime over the course of the event handler's run. This memory is &quot;owned&quot; by the handler so the event handler is the memory's &quot;lifetime&quot; and after the event handler has finished executing all memory associated with that handler is finally freed in a way that does not affect any other event handlers running on other threads (only if the CPU is truly single-core would there be a noticeable pause).</p>
<p>This &quot;coarse memory ownership model&quot; allows all code written in Alan to not have to worry about memory allocation and deallocation as if it had a Garbage Collector, but without the GC pause issue.</p>
<h3><a class="header" href="#type-inferred" id="type-inferred">Type Inferred</a></h3>
<p>Alan's type inference is capable of automatically inferring all function return types and all variable assignment types, only requiring function arguments to be typed. Once <a href="https://github.com/alantech/alan/blob/main/rfcs/006%20-%20Automatic%20Argument%20Interfaces%20RFC.md">this RFC</a> is implemented, it will be capable enough that <em>all</em> of the examples above do not need their types explicitly written out. The following would also work:</p>
<pre><code class="language-alan">on http.connection fn (conn) {
  let res = conn.res;
  res.body(&quot;Hello, World!&quot;).status(200).send();
}
</code></pre>
<pre><code class="language-alan">someLargeArray
  .filter(fn (val) = val &gt; someDefaultVal)
  .map(fn (val) = val.innerNumber * 3.14159)
  .reduce(fn (acc, cur) = acc + cur)
  .print();
</code></pre>
<pre><code class="language-alan">const data = http.get(&quot;https://someurl.com/csvfile.csv&quot;);
const datacsv = (data || '').split('\n').map(fn (row) = row.split(',').map(toInt64));
const data2 = http.get(&quot;https://someotherdatasource.org/othercsvfile.csv&quot;);
const data2csv = (data2 || '').split('\n').map(fn (row) = row.split(',').map(toInt64));
// Compare the data...
</code></pre>
<p>This allows you to be as concise or as explicit as you need to be, with very dynamic-looking code in a static language possible.</p>
<h2><a class="header" href="#what-alan-removes" id="what-alan-removes">What Alan Removes</a></h2>
<p>Any engineering endeavour is a balance of trade-offs, and some things must be removed to make room for all of the advantages laid out above.</p>
<p>Most languages tend to make a similar set of trade-offs, with the largest &quot;axis&quot; of trade-offs being on how static or dynamic the type system is, with C and Rust being far on the static side, Python and Lisp being dynamically typed but static once the variable is defined, and Perl and Javascript being fully dynamically typed where variables can be reassigned with new types and values can be implicitly casted between types. Alan has come down hard on the static typing side like Rust, but with a (soon-to-be) complete type inference system, as well, which we believe can help you &quot;have your cake and eat it, too.&quot;</p>
<p>Other trade-offs that Alan makes are significantly outside of the regular trade-offs that most languages make.</p>
<h3><a class="header" href="#parallel-computation-and-the-problem-of-turing-completeness" id="parallel-computation-and-the-problem-of-turing-completeness">Parallel Computation and the Problem of Turing-Completeness</a></h3>
<p>You may have noticed something missing from the examples above. Classic control flow! While there is <code>if</code>, there is no <code>while</code>, <code>do-while</code>, <code>for</code>, <code>until</code>, etc. You may be thinking &quot;with functions and if statements, I can use recursive calls to reconstruct these tools!&quot; <a href="https://media1.tenor.com/images/332e49d59e1571201639e28cc4371b60/tenor.gif">Well yes, but actually no.</a> The Alan compiler detects and fails on any direct recursive function calls, preventing this from occurring.</p>
<p>This means that the functions that <em>you can write</em> in Alan are not <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing Complete</a>, they are simply dependency graphs of operations to perform, meaning that any call to them is <em>guaranteed</em> to Halt. To iterate over an array, you must use one of the built-in array functions to do so, passing it a closure function to perform the logic per iteration, and the runtime has strong guarantees that this operation will not hold the thread forever. In fact, for anything not IO-bound, the runtime should be able to <em>predict</em> how much time it will take with these properties and could schedule work appropriately around it.</p>
<p>Should this array iteration be parallelized or not? That depends on the cost to scatter the array to multiple threads and the cost to gather the results back to the original thread versus the cost to execute the specified operations on each element of the array. Any combination of array size and closure operation is going to have a different set of thresholds between staying in 1 core versus 2, 3, 4, etc, and that threshold would also vary based on <em>how many other tasks</em> are running at the same time. Will it spend the scatter and gather penalty only to be queued and obliterate any potential performance gains from parallelization?</p>
<p>The Alan runtime does not yet do this, but the constraints of the language mean it is only a matter of time before it does, and allow the runtime to make performance decisions that no framework is capable of today, because it is able to &quot;reason&quot; about the behavior of your code to a much greater degree.</p>
<p>The problem with the classic control flow constructs is their Turing completeness. Even &quot;trivial&quot; fragments of code involving them are unpredictable. Consider the following snippet of C code:</p>
<pre><code class="language-c">while (node) {
  printf(node-&gt;data);
  node = node-&gt;child;
}
</code></pre>
<p>This code appears to iterate through a linked list and print all of the data in it to stdout. It appears to be equivalent to a simple <code>someArray.each(print)</code>. But what if this was the line just before this block of code:</p>
<pre><code class="language-c">node.child = &amp;node;
</code></pre>
<p>Now the <code>while</code> loop is an infinite loop and it will <a href="https://en.wikipedia.org/wiki/Halting_problem">never halt</a>. It &quot;isn't the while loop's fault,&quot; you may be thinking, the data is corrupt! That's the unfortunate point. The algorithms and the actual data structures together determine the running time and whether it will halt or not, and knowing that answer is necessary to parallelize automatically without accidentally causing performance regressions in some situations.</p>
<p>And so Alan intentionally controls the base algorithms and data structures, to make the automatic parallelism possible and to prevent runaway code from taking everything down with it. While it is true that there are questions that can never be answered, a language that prevents you from ever asking them means that you'll always be able to answer a request from your own user.</p>
<p>Finally, we do have <a href="https://github.com/alantech/alan/blob/main/rfcs/007%20-%20Sequential%20Algorithms%20RFC.md">a proposal to mostly restore these classic control flow tools</a> for the few problems that truly need them and cannot be cleanly solved with the functional tools provided, but must be provided a limit value on the number of iterations (that the runtime will eventually use to determine the expected execution time for planning purposes) to still guarantee halting, and are intentionally discouraged due to all of the deoptimizations they cause. This includes looping and recursion constructs as well as generator functions.</p>
<h3><a class="header" href="#a-static-event-system" id="a-static-event-system">A Static Event System</a></h3>
<p>Most languages do not bake an event loop into the language, with Javascript being a major exception. Others use a message passing system to named processes (Erlang, Go). None that we're aware of require the collection of events to be statically defined at compile time.</p>
<p>Alan makes this choice. This constrains the dynamism problem which makes the potential parallelization planner simpler  as it can know the total list of all event types and sources for those events. But this also makes possible another behavior in the compiler: massive function inlining. The Alan runtime does not have the concept of a function, it has collections of dependency graphs for each event it can process.</p>
<p>The entire function call graph has been squashed together per event, making each of them like a mini-process using the runtime to communicate with each other, and allowing the compiler to automatically squash duplicate constants and (in the future) pre-compute as much of the graph as possible at compile-time.</p>
<p>This decision should give Alan code a performance boost at runtime at the cost of compile time and code size (inlined code used in multiple event handlers has to be duplicated).</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Alan is not just another mixed-mode imperative/functional language with a slightly different syntactic skin. Through a delibrate and uncommon set of trade-off decisions, Alan can guarantee that you will have no uncontrolled runtime errors and that where possible it will parallelize your code, and in the future it will be able to do so without any explicitly defined types and without accidental performance regressions versus executing single-threaded.</p>
<p>These trade-offs have been chosen to minimize the amount of &quot;unusual&quot; patterns of logic so it doesn't get in your way, especially if you already write code in the recommended idiomatic forms of Typescript, Rust, etc. They are significant trade-offs, however. No unmanaged looping or recursion is allowed, and Alan functions are, on their own, not Turing complete, but we believe we have skimmed &quot;close enough&quot; to Turing completeness to maintain the vast majority of the utility involved but without many of the downsides.</p>
<h1><a class="header" href="#the-turing-completeness-problem" id="the-turing-completeness-problem">The Turing-Completeness Problem</a></h1>
<p><strong>4 November 2020 | Luis F. De Pombo, David Ellis</strong></p>
<p>Can we write programs with predictable execution that could be automatically parallelized? Part of the work of Alan Turing and Alonzo Church on <a href="https://en.wikipedia.org/wiki/Computability">computability</a> demonstrated that for some programs it cannot be determined ahead of time whether or not the program can be computed. This constitutes the crux of the <a href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>. This &quot;Turing-Completeness Problem&quot; is not an issue with what they have shown, but how the software development process is hindered by the lack of assurances on computability and our industry's lack of recognition of the burden this has put onto software developers. Further, it has been exacerbated by recent computing mechanisms, such as multithreading, NUMA, GPGPU, and distributed computing, which have moved away from the &quot;single tape&quot; Turing Machine model of computation that most programming languages are founded upon.</p>
<p>The following snippet of C code succinctly contains the problems of Turing completeness complicating modern development:</p>
<pre><code class="language-c">while (node) {
  doSomethingWith(node);
  node = node-&gt;next;
}
</code></pre>
<ol>
<li><em>Automatic Parallelization</em> - It's not possible to automatically parallelize this code. The number of nodes is not clear to the compiler for it to potentially bunch those calls across threads, and it's also unclear if the function call mutates the node and adds/removes nodes to process.</li>
<li><em>Halting Problem</em> - It's not possible to know if the code will halt, even ignoring the idea that <code>doSomethingWith</code> may always add a new <code>node</code> to the one it is processing, there's nothing stopping a node from pointing at itself and never halting that way.</li>
</ol>
<p>Automatic parallelization is only a problem because we want/need to parallelize our code. Until very recently this was a niche need as <a href="https://www.karlrupp.net/2015/06/40-years-of-microprocessor-trend-data/">computing power had been increasing exponentially for decades and has only flattened in the past decade</a>. If this was still the case it is likely that it would have remained a niche problem that only experts need to worry about, but with multicore now the norm even in personal laptops and unlikely to go away as <a href="http://www.fisgeo.unipg.it/luca.gammaitoni/fisinfo/documenti-fisici/physical-limits-silicon.pdf">signal propagation itself becomes the limiting factor</a>, it has become a problem for the average developer, as well.</p>
<p>The issue with the Halting Problem itself is much more contentious. Turing demonstrated that it is not possible to determine whether arbitrary compute will halt or run forever so this lack of determinism has been tolerated as an unfortunate reality of all compute that must simply be dealt with. However, we posit that no <em>practially useful</em> computation will take forever because its result cannot affect the finite reality of our lives, so programmers have already been finding an imperfect subset of Turing completeness for their own problem domains in an ad-hoc intuitive sense to be able to actually produce valuable calculations for their users.</p>
<p>In a single-threaded world, this problem has been mostly a small annoyance -- on those occasions where you have written infinitely-looping code, find the section of code that the processor is executing over and over again, study how it entered this state, and figure out how to prevent that state from occurring again -- or abort on detection of said state. But in a multi-threaded, multi-machined cluster computing world, on those occasions where you have written an infinite loop, even detecting an infinite loop that spans multiple machines is a challenge, let alone gathering the data you need to debug the cause of this invalid state. This is further exacerbated by the non-determinism inherent to multiple interacting Turing machines not executing in lockstep with each other making reproduction of the problem even more difficult.</p>
<p>Side-stepping the Halting Problem by defining a barely-Turing-incomplete subset, also makes the automatic parallelization story possible. Now the compiler can work with code that it can determine where and how it could parallelize the work and has the ability to model its finite execution time to determine whether or not parallelization is worth it under various conditions.</p>
<p>This is the thesis of <a href="https://github.com/alantech/alan">the Alan programming language</a>, that with minor syntax constraints (that we believe the vast majority of developers will not notice, or at least won't mind) we can be sure that the code you write always halts, and we can parallelize your code for you. We can make models for runtime estimates at compile time that only require the size and &quot;shape&quot; of the data to get an answer and can therefore determine not only how to parallelize your code, but whether or not it makes sense given the data being operated on. We have not yet accomplished all of these claims, but this is now only a matter of time and effort. :)</p>
<p>The root of most of the problems with the example C code involves the ambiguity in the data structure and the behavior of the user-defined function. The other problem is that the while loop is an unbounded looping construct that cannot be reasoned about except &quot;the body of the while loop is executed zero or more times.&quot; In Alan, <em>arbitrary</em> looping and recursion are disallowed, and all data is built on top of data types with knowable constraints, no arbitrary JUMP statements or data pointer logic allowed.</p>
<p>What this means in practice is that instead of writing that while loop above for your list of nodes, you would write something like:</p>
<pre><code class="language-ln">nodes.each(doSomethingWith);
</code></pre>
<p>Your intent to perform a side-effect action on each of the nodes in the list is clear, and the Alan compiler can determine the &quot;purity&quot; of the function -- whether or not it mutates the input argument or an outer scope -- to determine if it <em>could</em> execute the operations in parallel. Then at runtime it can use the estimated execution time of the function, the number of nodes in the <code>nodes</code> array, and the cost to distribute that work across multiple threads, to decide <em>if</em> it will execute the operations in parallel.</p>
<p>This can even apply across simple sequentially-written lines of code:</p>
<pre><code class="language-ln">fn example(file1: string, file2: string): Array&lt;Array&lt;int64&gt;&gt; {
  const matrix1 = loadFile(file1).parseMatrix();
  const matrix2 = loadFile(file2).parseMatrix();
  return matrix1 * matrix2;
}
</code></pre>
<p>Not only is the matrix multiplication a trivially parallelizable operation that likely will be parallelized for any large-ish matrix, but reading the files from disk and then parsing their contents may be done in parallel before the matrix multiplication because the performance benefit is there to do so.</p>
<p>To accomplish automatic parallelization, we need something different from a classic Turing tape to compile to. We call this the Alan Graphcode: a bytecode format with graph annotations that is guaranteed to have no cycles. A dependency graph of operations to perform, with some of these also having a subgraph of operations to perform, provides us with the information we need to know which operations are safe to execute in parallel, coupled with (implied) operation execution time estimates to determine if it makes sense to do so.</p>
<p>Alan's acyclic graphcode seems incompatible with any sort of control flow at first glance, though, since a dependency graph of operations that must all be executed appears to preclude the behavior of <code>JUMP</code> operations, like the classic <a href="https://www.aldeid.com/wiki/X86-assembly/Instructions/jnz">JNZ (Jump if Not Zero)</a>. <a href="https://github.com/alantech/alan">Alan</a> allows <code>if</code> statements and even <a href="https://docs.alan-lang.org/std_seq.html">guaranteed halting versions of classic looping constructs are in a standard library</a> that provide a predictable &quot;worst case&quot; execution time based on a maximum iteration count allowed. We will demonstrate how Alan allows control flow with a graph-based representation that makes automatic parallelization possible.</p>
<p><img src="./turing-tape.png" alt="Turing Tape Example with JNZ" /></p>
<p>Here two operations <code>OP1</code> and <code>OP2</code> run, then a <code>JNZ</code> runs. If the check is not zero, it skips to only run <code>OP5</code> and <code>OP6</code>, otherwise it runs <code>OP3</code> and <code>OP4</code> before running <code>OP5</code> and <code>OP6</code>.</p>
<p>This is a basic if statement for something like:</p>
<pre><code>var a = op1();
var b = op2(a);
if (b) {
  var c = op3();
  a = op4(c);
}
var d = op5(a);
return op6(d);
</code></pre>
<p>The equivalent representation in a graph would be something like:</p>
<p><img src="./graph-if.png" alt="Graph Example with if" /></p>
<p>Here, the conditional call is a special <code>COND</code> node that may or may not execute the specified graph named <code>if</code>. All of the nodes of the main graph are executed, but the <code>COND</code> operation may or may not execute the inner subgraph. There is absolutely no parallelization possible based on the set of dependencies, but it's clear that <code>OP5</code> can't run until both <code>OP1</code> and <code>COND(if)</code> are run.</p>
<p>Back to classic Turing machines, what is the opposite of an <code>if</code> statement in a Turing tape? It's not <code>else if</code> or <code>else</code> as those are just other forward jumps on different conditions. The opposite of an <code>if</code> is a <code>do-while</code> statement, because that is a jump <em>backwards</em>. </p>
<p><img src="./turing-loop.png" alt="Turing Tape Example with JNZ-based loop" /></p>
<pre><code>var a = op1();
var b = op2(a);
do {
  var c = op3();
  a = op4(c);
  var d = op5(a);
} while (d);
op6(a);
</code></pre>
<p>The equivalent in a graph representation would be:</p>
<p><img src="./graph-loop.png" alt="Graph Example with do-while loop" /></p>
<p>Here a <code>DOWHILE</code> opcode runs the loop sub-graph over and over until the expected condition is met. So with these two special opcodes <code>COND</code> and <code>DOWHILE</code> we can reproduce the behavior of <code>JNZ</code>'s forwards and backwards jumping and we can enter infinite loops with <code>DOWHILE</code>, meaning we should be Turing Complete.</p>
<p>So how do we make this barely <em>not</em> Turing complete? We make a list/array type a first class citizen in the VM itself and then we only add operations that know the bounds that they are to operate on based on that list or some other condition that cannot be <em>directly</em> mutated by the user's own code.</p>
<p>Now for an array of data we can have an <code>each</code> opcode that applies a given sub-graph of operations to every node in the array. The Alan runtime, or AVM, can tell based on the expected execution time of the graph and the number of nodes and the cost to send that data to multiple threads whether or not to do a fork-join or not. Probably no for 10 elements and probably yes for 10 billion, but where's the threshold and why? That's something better left for a computer to decide in realtime based on the data rather than a developer.</p>
<p>This is the fundamental structure behind <a href="https://github.com/alantech/alan">Alan</a> and it's AVM. There are more goodies around automatic transforms of the graph to better optimize IO that we have partially working right now and automatic rewriting of the graph for stream processing that we're still figuring out, but with just this we can get better parallelization strategies automatically while keeping your own code short and clean.</p>

            </main>

            <nav class="nav-wrapper" aria-label="Page navigation">
              <!-- Mobile navigation buttons -->
              

              

              <div style="clear: both"></div>
            </nav>
        </div>
    </div>

</div>


<script type="text/javascript">
  // we are doing this here because handlebars does not allow evaluation in its conditionals
  // and mdbook does not allow defining handlebars helpers
  var dynNav = document.getElementById('dyn-navigation')
  if ("" === "Alan Language") {
    // hide book title
    document.getElementsByClassName('menu-title')[0].textContent = ""
    // hide left buttons in menu to search or toggle sidebar
    document.getElementById('left-menu').style.display = 'none'
    // link to blog
    dynNav.innerHTML = "<i>Blog</i>"
    dynNav.title = "Blog"
    dynNav.href = "/blog.html"
  } else {
    // hide first element in toc
    var tocLi = document.getElementsByTagName("li")
    tocLi[0].innerHTML = ""
    // link to homepage
    dynNav.innerHTML = "<i>Home</i>"
    dynNav.title = "Alan Language"
    dynNav.href = "/"
  }
</script>



<!-- Analytics Tag -->
<script type="text/javascript">
  var localAddrs = ["localhost", "127.0.0.1", ""];

  // make sure we don't activate analytics if the developer is
  // inspecting the book locally...
  if (localAddrs.indexOf(document.location.hostname) === -1) {
    !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(e){return function(){var t=Array.prototype.slice.call(arguments);t.unshift(e);analytics.push(t);return analytics}};for(var e=0;e<analytics.methods.length;e++){var t=analytics.methods[e];analytics[t]=analytics.factory(t)}analytics.load=function(e,t){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+e+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=t};analytics.SNIPPET_VERSION="4.1.0";
      analytics.load("fGya8GY5wLqdnLzyXnGM2HjYglPszWS0");
      if ("" === "Homepage" || "" === "Alan Language") {
        analytics.page("Homepage");
      } else {
        analytics.page("Blog", "");
      }
    }}();
  } else {
    window.analytics = {
      track: function(...args) {},
      page: function(...args) {},
    }
  }
</script>


    <script type="text/javascript">
        window.playpen_line_numbers = true;
    </script>



    <script type="text/javascript">
        window.playpen_copyable = true;
    </script>



    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>


<!-- BigInt is not defined in Safari. Define it before loading bundle.js -->
<script type="text/javascript">
    window.BigInt = window.BigInt || function() {}
</script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<!-- Custom JS scripts -->

    <script type="text/javascript" src="bundle.js"></script>

    <script type="text/javascript" src="hljs-alan.min.js"></script>

    <script type="text/javascript" src="mode-rust.js"></script>

    <script type="text/javascript" src="theme-solarized_dark.js"></script>

    <script type="text/javascript" src="theme-solarized_light.js"></script>

<script src="book.js" type="text/javascript" charset="utf-8"></script>

</body>
</html>