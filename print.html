<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Alan Language</title>

    <!-- Custom HTML head -->
    

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="The Alan Programming Language">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />
    <meta property="og:title" content="Alan Language">
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://alan-lang.org/alan-logo.png">
    <meta property="og:description" content="The Alan Programming Language">
    <meta property="og:url" content="https://alan-lang.org">
    <meta name="twitter:card" content="summary" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
        <link rel="stylesheet" href="css/solarized-light-hljs.css">
    
        <link rel="stylesheet" href="css/solarized-dark-hljs.css">
    
        <link rel="stylesheet" href="css/override.css">
    

</head>

<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "solarized-dark" : "solarized-light";
    var html = document.querySelector('html');
    html.classList.add(default_theme);
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
  try {
    var sidebar = localStorage.getItem('mdbook-sidebar');

    if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
      localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
    }
  } catch (e) { }
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
  var html = document.querySelector('html');
  var sidebar;
  html.classList.remove('sidebar-visible');
  if (document.body.clientWidth >= 1080 && "" !== "Alan Language") {
    try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { console.error(e) }
    sidebar = sidebar || 'visible';
  } else {
    sidebar = 'hidden'
  }
  html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
  <div class="sidebar-scrollbox">
    <ol class="chapter"><li class="chapter-item expanded affix "><a href="homepage.html">Alan Language</a></li><li class="chapter-item expanded affix "><a href="blog.html">Blog</a></li><li class="chapter-item expanded "><a href="why_alan.html"><strong aria-hidden="true">1.</strong> Why we created Alan</a></li><li class="chapter-item expanded "><a href="alan_overview.html"><strong aria-hidden="true">2.</strong> An Overview of Alan</a></li></ol>
  </div>
  <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
      
      <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
          <div id="left-menu" class="left-buttons">
            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
              <i class="fa fa-bars"></i>
            </button>
            
              <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                <i class="fa fa-search"></i>
              </button>
            
          </div>

          <h1 class="menu-title">Alan Language</h1>

          <div class="right-buttons">
            <a id="dyn-navigation">
            </a>
            <a href="https://docs.alan-lang.org" title="Documentation">
              <i>Docs</i>
            </a>
            <a href="https://github.com/alantech/alan" title="Documentation">
              <i>Github</i>
            </a>
          </div>
        </div>
        
          <div id="search-wrapper" class="hidden">
            <form id="searchbar-outer" class="searchbar-outer">
              <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
            </form>
            <div id="searchresults-outer" class="searchresults-outer hidden">
              <div id="searchresults-header" class="searchresults-header"></div>
              <ul id="searchresults">
              </ul>
            </div>
          </div>
        

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
          document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
          document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
          Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
            link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
          });
        </script>
        <div id="content" class="content">
            <main>
                <p> </p>
<center>
  <img src="alan-logo.png" alt="drawing" width="180"/>
  <h1 style="color: var(--title);">The Alan Programming Language</h1>
</center>
<div class="row">
  <div class="column">
    <center>
      <img src="implicit-parallel.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">Implicitly parallel across events, arrays and IO</h3>
    Alan recognizes and exploits opportunities for parallelization without parallel programming (threads, channels, futures, locks, etc.)
  </div>
  <div class="column">
    <center>
      <img src="runtime-safety.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">No race conditions and fewer runtime errors</h3>
    Deadlocks, livelocks, undefined variables, divide-by-zero, integer under/overflow, array out-of-bounds access, etc, are not possible in Alan.
  </div>
  <div class="column">
    <center>
      <img src="permissions.png" alt="drawing" width="120"/>
    </center>
    <h3 style="margin-top:0;">Granular third party permissions</h3>
    Alan's module resolution mechanism allows you to prevent third party dependencies from having access to standard libraries that they should not have access to.
  </div>
</div>
<p> </p>
<h2><a class="header" href="#try-alan" id="try-alan">Try Alan</a></h2>
<table style="width: 100%;">
<tr>
<th></th>
<th></th>
</tr>
<tr>
<td>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">import @std/app

on app.start {
  app.print(&quot;Hello, World!&quot;)
  emit app.exit 0
}
</code></pre></pre>
</td>
</table>
<p><a id="run-playground" onclick="analytics.track('RunPlayground');" class="cta-button">Run this code</a></p>
<h2><a class="header" href="#compare-alan" id="compare-alan">Compare Alan</a></h2>
<center>
  <div class="carousel-container">
    <ul class="carousel my-carousel carousel--thumb">
      <input class="carousel__activator" type="radio" id="1" name="thumb" checked="checked"/>
      <input class="carousel__activator" type="radio" id="2" name="thumb"/>
      <input class="carousel__activator" type="radio" id="3" name="thumb"/>
      <div class="carousel__controls">
        <label class="carousel__control carousel__control--backward" for="3"></label>
        <label class="carousel__control carousel__control--forward" for="2"></label>
      </div>
      <div class="carousel__controls">
        <label class="carousel__control carousel__control--backward" for="1"></label>
        <label class="carousel__control carousel__control--forward" for="3"></label>
      </div>
      <div class="carousel__controls">
        <label class="carousel__control carousel__control--backward" for="2"></label>
        <label class="carousel__control carousel__control--forward" for="1"></label>
      </div>
      <li class="carousel__slide"><!-- Fake for weird CSS reasons --></li>
      <li class="carousel__slide">
        <pre class="code-border"><code class="language-alan">
  /* ALAN runs array operations in parallel
  utilizing all the available CPU cores
  if the array is large enough
  and the inner function given to it is pure. */
  fn sumMaybeConcurrent(nums: Array&lt;int&gt;): int {
    return nums.reducePar(fn (accum: int, val: int): int = accum + val)
  }
        </code></pre>
        <pre class="code-border"><code class="language-golang">
  /* GOLANG
  https://play.golang.org/p/yB7gR3r09ZU
  */
  func sum(nums []int, out chan int) {
    var sum int
    for _, num := range nums {
      sum += num
    }
    out <- sum
  }
<p>func sumConcurrent(numbers []int) int {
threads := runtime.NumCPU() - 1
out := make(chan int)
stride := len(numbers) / threads</p>
<pre><code>for i := 0; i &lt; threads; i++ {
  go sum(numbers[i*stride:(i*stride)+stride], out)
}
go sum(numbers[threads*stride:len(numbers)], out)

var s int
for i := 0; i &lt;= threads; i++ {
  s += &lt;-out
}
return s
</code></pre>
<p>}
</code></pre>
</li>
<li class="carousel__slide">
<pre class="code-border"><code class="language-alan">
/* ALAN <em>/
fn fetchAndSum(urls: Array&lt;string&gt;): int {
return urls
.map(fn (url: string): int {
const website = http.get(url) || http.none
return toString(website.body).length()
})
.reducePar(fn (accum: int, val: int): int = accum + val)
}
</code></pre>
<pre class="code-border"><code class="language-java">
/</em> JAVA <em>/
Integer fetchAndSum(String...urls) {
var sum = CompletableFuture.completedFuture(0);
try {
return Stream
.of(urls)
.parallel()
.map(url -&gt; httpClient
.sendAsync(request(url), BodyHandlers.ofString())
.thenApply(HttpResponse::body)
.thenApply(String::length))
.reduce(sum, (prev, curr) -&gt; prev
.thenCombine(curr, (p, c) -&gt; p + c))
.get();
} catch(Exception e){
System.out.println(e.toString());
return 0;
}
}
</code></pre>
</li>
<li class="carousel__slide">
<pre class="code-border"><code class="language-alan">
/</em> ALAN automatically executes IO concurrently when possible <em>/
fn getValidUids() {
const authUids = Auth.getAllUsers().map(fn (u: AuthUser): int = u.id)
const dbUids = Store.getAllUsers().map(fn (u: User): int = u.uid)
const crmUids = Crm.getAllUsers().map(fn (u: CrmUser): int = u.uid)
return authUids.filter(fn (v: int): bool = dbUids.has(v) &amp;&amp; crmUids.has(v))
}
</code></pre>
<pre class="code-border"><code class="language-javascript">
/</em> NODE.JS equivalent */
async function getValidUids() {
const [authUsers, dbUsers, crmUsers] = await Promise.all([
Auth.getAll(),
Store.getAllUsers(),
Crm.getAllUsers()
]);
const authUids = authUsers.map(u =&gt; u['id']);
const dbUids = dbUsers.map(u =&gt; u['uid']);
const crmUids = crmUsers.map(u =&gt; u['uid']);
return authUids.filter(v =&gt; dbUids.includes(v) &amp;&amp; crmUids.includes(v))
}
</code></pre>
</li>
<div class="carousel__indicators">
<label class="carousel__indicator" for="1"></label>
<label class="carousel__indicator" for="2"></label>
<label class="carousel__indicator" for="3"></label>
</div>
</ul></p>
</div>
</center>
<p> </p>
<center>
  <a href="https://docs.alan-lang.org/getting_started.html" onclick="analytics.track('DownloadCTA');" class="cta-button">Get Started</a>
</center>
<h2><a class="header" href="#contact" id="contact">Contact</a></h2>
<p>Please reach out on <a href="https://discord.gg/XatB9we">Discord</a>, Reddit (https://www.reddit.com/r/alanlang) or email us at hello at alantechnologies dot com.</p>
<h1><a class="header" href="#blog" id="blog">Blog</a></h1>
<ul>
<li><a href="./why_alan.html">Why we created Alan</a> | 2020-08-14</li>
<li><a href="./alan_overview.html">An Overview of Alan</a> | 2020-08-16</li>
</ul>
<h1><a class="header" href="#why-we-created-alan" id="why-we-created-alan">Why we created Alan</a></h1>
<p><strong>14 August 2020 | David Ellis, Luis F. De Pombo</strong></p>
<p>We created a programming language to be able to write concurrent algorithms and business logic without having to explicitly program how it should be parallelized. Alan makes people more productive by managing IO and computational parallelism for them in the same way languages from the 90s like Java and Python made people more productive, when compared to C or C++, by managing memory for them.</p>
<p>Why the name? Alan is named in honor of Alan Turing. We find great inspiration in the magnitude of his intellectual contributions.</p>
<h4><a class="header" href="#implicit-parallelization-over-arrays-events-and-io" id="implicit-parallelization-over-arrays-events-and-io">Implicit parallelization over arrays, events and IO</a></h4>
<p>Alan is <a href="./alan_overview.html#implicitly-parallel">implicitly parallel</a> because its compiler and runtime exploits opportunities for parallelization across the computing resources available without being told to do so. We have <a href="./alan_overview.html#parallel-computation-and-the-problem-of-turing-completeness">constrained the language a bit</a> to provide better opportunities to do this. This results in nimbler codebases than those built with languages or frameworks that use parallel programming constructs such as threads, actors, channels, locks, futures, promises etc.</p>
<h4><a class="header" href="#no-race-conditions-and-fewer-runtime-errors" id="no-race-conditions-and-fewer-runtime-errors">No race conditions and fewer runtime errors</a></h4>
<p>Deadlocks, livelocks, undefined variables, divide-by-zero, integer under/overflow, array out-of-bounds access, etc, are not possible in Alan. Only out-of-memory errors persist, but they are impossible to avoid. This makes Alan codebases easier to maintain and develop in because <a href="./alan_overview.html#statically-compiled-benefits-and-compile-time-safety">runtime errors are nearly always caught at compile time</a>.</p>
<h4><a class="header" href="#granular-third-party-permissions" id="granular-third-party-permissions">Granular third party permissions</a></h4>
<p>Alan's module resolution mechanism, with mocking built-in, allows you to <a href="./alan_overview.html#third-party-module-permission-system">prevent specific third-party dependencies from having access to  specific standard libraries</a> that they should not have access to.</p>
<h4><a class="header" href="#no-gc-pauses" id="no-gc-pauses">No GC pauses</a></h4>
<p>Alan’s runtime manages memory allocation, access, and deallocation for you like Java, Python, or Javascript. However, Alan’s static event system and <a href="./alan_overview.html#memory-management">automatic event-oriented memory model</a> does so without garbage collector pauses.</p>
<h4><a class="header" href="#join-us" id="join-us">Join Us</a></h4>
<p>There is still a ways to go for Alan to become a worthy abstraction to automatically parallelize software, but if you are moved by the vision please try it out, give us your feedback and help us shape it.</p>
<h1><a class="header" href="#an-overview-of-alan" id="an-overview-of-alan">An Overview of Alan</a></h1>
<p><strong>16 August 2020 | Luis F. De Pombo, David Ellis</strong></p>
<p>Programming languages are useful not only for what they allow, but what they prevent. That is the key separation between a language and a framework. For good or for ill, a framework can be sidestepped by its users while a language can't.</p>
<p>This overview of Alan will emphasize just as much what it prevents you from doing as what it provides to you. We believe our blend of features and omissions is what general purpose computing needs in the multicore era.</p>
<h2><a class="header" href="#what-alan-provides" id="what-alan-provides">What Alan Provides</a></h2>
<p>Alan is a natively-parallel, statically-compiled, type-inferred, evented language with a familiar syntax and many compile-time and run-time safety guarantees.</p>
<h3><a class="header" href="#implicitly-parallel" id="implicitly-parallel">Implicitly Parallel</a></h3>
<p>Alan's compiler and runtime automatically recognizes and exploits the parallelism inherent to the computations expressed by some of the language's constructs and automatically managing IO and compute threadpools.</p>
<p><strong>Parallelism over events</strong> is accomplished via the static event system baked into the language:</p>
<pre><code class="language-alan">on http.connection fn (conn: http.Connection) {
  let res: http.Request = conn.res
  res.body(&quot;Hello, World!&quot;).status(200).send()
}
</code></pre>
<p>Independent connections to the HTTP server are scheduled onto the event loop and the compute threadpool pulls them from the queue and executes them in parallel.</p>
<p><strong>Parallelism over arrays</strong> if the array is large enough and the inner function given to it is pure, each of these steps will run in parallel, utilizing all of the CPU cores on the machine:</p>
<pre><code class="language-alan">someLargeArray
  .filter(fn (val: SomeType): bool = val &gt; someDefaultVal)
  .map(fn (val: SomeType): float64 = val.innerNumber * 3.14159)
  .reducePar(fn (acc: float64, cur: float64): float64 = acc + cur)
  .print()
</code></pre>
<p>The developer needs to know when to use <code>reducePar</code> vs <code>reduce</code>. It would be great to have auto-parallelism on <code>reduce</code> like every other array operation, but that would require the compiler to be able to prove commutative/associative properties on closures. </p>
<p><strong>IO Concurrency</strong> is accomplished by eagerly running IO-bound opcodes within the runtime based on the dependency graph of statements:</p>
<pre><code class="language-alan">const data: Result&lt;string&gt; = http.get(&quot;https://someurl.com/csvfile.csv&quot;)
const datacsv: Array&lt;Array&lt;int64&gt;&gt; = (data || '').split('\n').map(fn (row: string): Array&lt;int64&gt; = row.split(',').map(toInt64))
const data2: Result&lt;string&gt;  = http.get(&quot;https://someotherdatasource.org/othercsvfile.csv&quot;)
const data2csv: Array&lt;Array&lt;int64&gt;&gt; = (data2 || '').split('\n').map(fn (row: string): Array&lt;int64&gt; = row.split(',').map(toInt64))
// Compare the data...
</code></pre>
<p>The Alan runtime will see that the two URL fetches do not depend on each other and can run in parallel, so they will be hoisted to the top of the function call, executed in parallel, and the function execution continues after they return, minimizing overall latency and scheduling costs.</p>
<h3><a class="header" href="#statically-compiled-benefits-and-compile-time-safety" id="statically-compiled-benefits-and-compile-time-safety">Statically Compiled Benefits and Compile-Time Safety</a></h3>
<p>Alan has a multi-stage compiler with two compile targets: It's own native AGC bytecode format to be run by its native runtime, and Javascript to allow running in Node.js or the browser.</p>
<p>This will make it possible to make full-stack web applications in Alan that can also be ejected to Javascript if you no longer wish to develop in Alan. (&quot;Will&quot; because the cross-compiler's primary focus has been on correctness, not legibility, of the generated Javascript, but that will improve over time. Also because Alan bindings to Web APIs have not yet been written.)</p>
<p>Being statically compiled brings lots of benefits (and a few drawbacks) to the table. Primarily, the compiler can spot and prevent many classes of trivial errors from getting into production, but at the expense of requiring a compilation step between checking the changes made to your code.</p>
<p>However, Alan takes the safety guarantees to a higher level:</p>
<ul>
<li><strong>No <code>undefined</code> variables, ever:</strong> In Alan, <code>let</code> or <code>const</code> declared variables <em>must</em> be given an initial value. Potentially missing data can be represented with a <code>Maybe&lt;T&gt;</code> type, but then the compiler will force checking for the presence of actual data or providing a default value if not present. Downstream logic can be assured that the type they are working with is real.</li>
<li><strong>Most runtime errors impossible:</strong> Out of memory errors are impossible to avoid, but other issues, such as divide-by-zero, integer under/overflow, array out-of-bounds accesses, etc, are not possible in Alan. Actions that could have runtime errored in other languages are converted into <code>Result&lt;T&gt;</code> types that have to be checked for an error condition and/or have a default value provided instead. (The default set of math operators return <code>Result</code>-wrapped values and can accept such values in place of raw integers or floats, but there is also a second set of math operators copying Rust's <a href="https://doc.rust-lang.org/std/intrinsics/fn.saturating_add.html">saturating arithmetic</a> mechanism that always works on raw integers or floats, and will produce predictable but potentially unexpected values when a runtime error would have been reached, otherwise.)</li>
<li><strong>Deadlocks, Livelocks, and other multithreading issues impossible:</strong> There is no explicit multithreading in Alan. The compiler determines what code you have written is safely parallelizable does this for you. As Alan's compiler and runtime become more intelligent, more code will become parallelized, but with most array operations already being parallelizable as well as all events, the majority of the parallelization possibilities are already covered.</li>
<li><strong>No shared, mutable state:</strong> Alan defers all such responsibility to databases and caching systems that have had decades of work behind them and many tradeoffs between different mechanisms. We may revisit this if we can bring something to the table here with a significant advantage and minimal downsides in the future, however.</li>
</ul>
<h3><a class="header" href="#third-party-module-permission-system" id="third-party-module-permission-system">Third-Party Module Permission System</a></h3>
<p>Beyond direct code and syntax safety guarantees, Alan also provides safety mechanisms on third-party modules. Alan's module resolution mechanism includes built-in support for <a href="https://docs.alan-lang.org/module_testing.html">defining mocks</a> and, more importantly, <a href="https://docs.alan-lang.org/module_mutation.html">defining mutations</a> of existing modules. This mechanism can be used to deny third party libraries access to parts of the standard library you are not comfortable with. By simply creating a <code>modules</code> directory within the third-party dependency and then defining an <code>std/app.ln</code> file that re-exports non-functional versions of the types, functions, and events of the original standard library, you can prevent that library from being able to use standard library features you would not expect them to have access to. For instance, if you have imported a very popular utility library for, say, curve fitting. You would not expect it to want to have access to your filesystem or creating a child process, so you could inject nonfunctional mocks of <code>@std/fs</code> and <code>@std/cmd</code>.</p>
<p>This causes the third party code to be compiled without the opcodes it needs to access that functionality at all, providing a defense-in-depth that can be applied along with standard auditing, package signing, and CVE reporting on open source projects. Making this behavior easy-to-use automatically through the package management system is a project goal that will provide users of Alan a layer of security no other project approaches.</p>
<h3><a class="header" href="#memory-management" id="memory-management">Memory Management</a></h3>
<p>Most safety in Alan is tackled at compile-time, where it belongs, so you can write code that handles it and it doesn't cause an issue in production. But one major piece that is handled by the runtime for you is memory allocation, access, and deallocation, and Alan does so without GC pauses.</p>
<p>Languages that handle memory management for you, like Java or Python, tend to be more productive languages to work in, with the cost of a Garbage Collector periodically pausing your code to find and clean up unused memory. Languages without that, like C or C++, require extra cognitive overhead to manage it, but tend to be faster and have a lower memory footprint.</p>
<p>In Alan, memory is allocated at the beginning of an event handler's run for all &quot;stack-like&quot; variables (basic constants and variables in the handler and all functions it uses) while &quot;heap-like&quot; variables (arrays and user types) are allocated as needed to the size needed at runtime over the course of the event handler's run. This memory is &quot;owned&quot; by the handler so the event handler is the memory's &quot;lifetime&quot; and after the event handler has finished executing all memory associated with that handler is finally freed in a way that does not affect any other event handlers running on other threads (only if the CPU is truly single-core would there be a noticeable pause).</p>
<p>This &quot;coarse memory ownership model&quot; allows all code written in Alan to not have to worry about memory allocation and deallocation as if it had a Garbage Collector, but without the GC pause issue.</p>
<h3><a class="header" href="#type-inferred" id="type-inferred">Type Inferred</a></h3>
<p>Alan's type inference is capable of automatically inferring all function return types and all variable assignment types, only requiring function arguments to be typed. Once <a href="https://github.com/alantech/alan/blob/main/rfcs/006%20-%20Automatic%20Argument%20Interfaces%20RFC.md">this RFC</a> is implemented, it will be capable enough that <em>all</em> of the examples above do not need their types explicitly written out. The following would also work:</p>
<pre><code class="language-alan">on http.connection fn (conn) {
  let res = conn.res
  res.body(&quot;Hello, World!&quot;).status(200).send()
}
</code></pre>
<pre><code class="language-alan">someLargeArray
  .filter(fn (val) = val &gt; someDefaultVal)
  .map(fn (val) = val.innerNumber * 3.14159)
  .reduce(fn (acc, cur) = acc + cur)
  .print()
</code></pre>
<pre><code class="language-alan">const data = http.get(&quot;https://someurl.com/csvfile.csv&quot;)
const datacsv = (data || '').split('\n').map(fn (row) = row.split(',').map(toInt64))
const data2 = http.get(&quot;https://someotherdatasource.org/othercsvfile.csv&quot;)
const data2csv = (data2 || '').split('\n').map(fn (row) = row.split(',').map(toInt64))
// Compare the data...
</code></pre>
<p>This allows you to be as concise or as explicit as you need to be, with very dynamic-looking code in a static language possible.</p>
<h2><a class="header" href="#what-alan-removes" id="what-alan-removes">What Alan Removes</a></h2>
<p>Any engineering endeavour is a balance of trade-offs, and some things must be removed to make room for all of the advantages laid out above.</p>
<p>Most languages tend to make a similar set of trade-offs, with the largest &quot;axis&quot; of trade-offs being on how static or dynamic the type system is, with C and Rust being far on the static side, Python and Lisp being dynamically typed but static once the variable is defined, and Perl and Javascript being fully dynamically typed where variables can be reassigned with new types and values can be implicitly casted between types. Alan has come down hard on the static typing side like Rust, but with a (soon-to-be) complete type inference system, as well, which we believe can help you &quot;have your cake and eat it, too.&quot;</p>
<p>Other trade-offs that Alan makes are significantly outside of the regular trade-offs that most languages make.</p>
<h3><a class="header" href="#parallel-computation-and-the-problem-of-turing-completeness" id="parallel-computation-and-the-problem-of-turing-completeness">Parallel Computation and the Problem of Turing-Completeness</a></h3>
<p>You may have noticed something missing from the examples above. Classic control flow! While there is <code>if</code>, there is no <code>while</code>, <code>do-while</code>, <code>for</code>, <code>until</code>, etc. You may be thinking &quot;with functions and if statements, I can use recursive calls to reconstruct these tools!&quot; <a href="https://media1.tenor.com/images/332e49d59e1571201639e28cc4371b60/tenor.gif">Well yes, but actually no.</a> The Alan compiler detects and fails on any direct recursive function calls, preventing this from occurring.</p>
<p>This means that the functions that <em>you can write</em> in Alan are not <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing Complete</a>, they are simply dependency graphs of operations to perform, meaning that any call to them is <em>guaranteed</em> to Halt. To iterate over an array, you must use one of the built-in array functions to do so, passing it a closure function to perform the logic per iteration, and the runtime has strong guarantees that this operation will not hold the thread forever. In fact, for anything not IO-bound, the runtime should be able to <em>predict</em> how much time it will take with these properties and could schedule work appropriately around it.</p>
<p>Should this array iteration be parallelized or not? That depends on the cost to scatter the array to multiple threads and the cost to gather the results back to the original thread versus the cost to execute the specified operations on each element of the array. Any combination of array size and closure operation is going to have a different set of thresholds between staying in 1 core versus 2, 3, 4, etc, and that threshold would also vary based on <em>how many other tasks</em> are running at the same time. Will it spend the scatter and gather penalty only to be queued and obliterate any potential performance gains from parallelization?</p>
<p>The Alan runtime does not yet do this, but the constraints of the language mean it is only a matter of time before it does, and allow the runtime to make performance decisions that no framework is capable of today, because it is able to &quot;reason&quot; about the behavior of your code to a much greater degree.</p>
<p>The problem with the classic control flow constructs is their Turing completeness. Even &quot;trivial&quot; fragments of code involving them are unpredictable. Consider the following snippet of C code:</p>
<pre><code class="language-c">while (node) {
  printf(node-&gt;data);
  node = node-&gt;child;
}
</code></pre>
<p>This code appears to iterate through a linked list and print all of the data in it to stdout. It appears to be equivalent to a simple <code>someArray.each(print)</code>. But what if this was the line just before this block of code:</p>
<pre><code class="language-c">node.child = &amp;node;
</code></pre>
<p>Now the <code>while</code> loop is an infinite loop and it will <a href="https://en.wikipedia.org/wiki/Halting_problem">never halt</a>. It &quot;isn't the while loop's fault,&quot; you may be thinking, the data is corrupt! That's the unfortunate point. The algorithms and the actual data structures together determine the running time and whether it will halt or not, and knowing that answer is necessary to parallelize automatically without accidentally causing performance regressions in some situations.</p>
<p>And so Alan intentionally controls the base algorithms and data structures, to make the automatic parallelism possible and to prevent runaway code from taking everything down with it. While it is true that there are questions that can never be answered, a language that prevents you from ever asking them means that you'll always be able to answer a request from your own user.</p>
<p>Finally, we do have <a href="https://github.com/alantech/alan/blob/main/rfcs/007%20-%20Sequential%20Algorithms%20RFC.md">a proposal to mostly restore these classic control flow tools</a> for the few problems that truly need them and cannot be cleanly solved with the functional tools provided, but must be provided a limit value on the number of iterations (that the runtime will eventually use to determine the expected execution time for planning purposes) to still guarantee halting, and are intentionally discouraged due to all of the deoptimizations they cause. This includes looping and recursion constructs as well as generator functions.</p>
<h3><a class="header" href="#a-static-event-system" id="a-static-event-system">A Static Event System</a></h3>
<p>Most languages do not bake an event loop into the language, with Javascript being a major exception. Others use a message passing system to named processes (Erlang, Go). None that we're aware of require the collection of events to be statically defined at compile time.</p>
<p>Alan makes this choice. This constrains the dynamism problem which makes the potential parallelization planner simpler  as it can know the total list of all event types and sources for those events. But this also makes possible another behavior in the compiler: massive function inlining. The Alan runtime does not have the concept of a function, it has collections of dependency graphs for each event it can process.</p>
<p>The entire function call graph has been squashed together per event, making each of them like a mini-process using the runtime to communicate with each other, and allowing the compiler to automatically squash duplicate constants and (in the future) pre-compute as much of the graph as possible at compile-time.</p>
<p>This decision should give Alan code a performance boost at runtime at the cost of compile time and code size (inlined code used in multiple event handlers has to be duplicated).</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Alan is not just another mixed-mode imperative/functional language with a slightly different syntactic skin. Through a delibrate and uncommon set of trade-off decisions, Alan can guarantee that you will have no uncontrolled runtime errors and that where possible it will parallelize your code, and in the future it will be able to do so without any explicitly defined types and without accidental performance regressions versus executing single-threaded.</p>
<p>These trade-offs have been chosen to minimize the amount of &quot;unusual&quot; patterns of logic so it doesn't get in your way, especially if you already write code in the recommended idiomatic forms of Typescript, Rust, etc. They are significant trade-offs, however. No unmanaged looping or recursion is allowed, and Alan functions are, on their own, not Turing complete, but we believe we have skimmed &quot;close enough&quot; to Turing completeness to maintain the vast majority of the utility involved but without many of the downsides.</p>

            </main>

            <nav class="nav-wrapper" aria-label="Page navigation">
              <!-- Mobile navigation buttons -->
              

              

              <div style="clear: both"></div>
            </nav>
        </div>
    </div>

</div>


<script type="text/javascript">
  // we are doing this here because handlebars does not allow evaluation in its conditionals
  // and mdbook does not allow defining handlebars helpers
  var dynNav = document.getElementById('dyn-navigation')
  if ("" === "Alan Language") {
    // hide book title
    document.getElementsByClassName('menu-title')[0].textContent = ""
    // hide left buttons in menu to search or toggle sidebar
    document.getElementById('left-menu').style.display = 'none'
    // link to blog
    dynNav.innerHTML = "<i>Blog</i>"
    dynNav.title = "Blog"
    dynNav.href = "/blog.html"
  } else {
    // hide first element in toc
    var tocLi = document.getElementsByTagName("li")
    tocLi[0].innerHTML = ""
    // link to homepage
    dynNav.innerHTML = "<i>Home</i>"
    dynNav.title = "Alan Language"
    dynNav.href = "/"
  }
</script>



<!-- Analytics Tag -->
<script type="text/javascript">
  var localAddrs = ["localhost", "127.0.0.1", ""];

  // make sure we don't activate analytics if the developer is
  // inspecting the book locally...
  if (localAddrs.indexOf(document.location.hostname) === -1) {
    !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(e){return function(){var t=Array.prototype.slice.call(arguments);t.unshift(e);analytics.push(t);return analytics}};for(var e=0;e<analytics.methods.length;e++){var t=analytics.methods[e];analytics[t]=analytics.factory(t)}analytics.load=function(e,t){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+e+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=t};analytics.SNIPPET_VERSION="4.1.0";
      analytics.load("fGya8GY5wLqdnLzyXnGM2HjYglPszWS0");
      if ("" === "Homepage" || "" === "Alan Language") {
        analytics.page("Homepage");
      } else {
        analytics.page("Blog", "");
      }
    }}();
  } else {
    window.analytics = {
      track: function(...args) {},
      page: function(...args) {},
    }
  }
</script>


    <script type="text/javascript">
        window.playpen_line_numbers = true;
    </script>



    <script type="text/javascript">
        window.playpen_copyable = true;
    </script>



    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>


<!-- BigInt is not defined in Safari. Define it before loading bundle.js -->
<script type="text/javascript">
    window.BigInt = window.BigInt || function() {}
</script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<!-- Custom JS scripts -->

    <script type="text/javascript" src="bundle.js"></script>

    <script type="text/javascript" src="hljs-alan.min.js"></script>

    <script type="text/javascript" src="mode-rust.js"></script>

    <script type="text/javascript" src="theme-solarized_dark.js"></script>

    <script type="text/javascript" src="theme-solarized_light.js"></script>

<script src="book.js" type="text/javascript" charset="utf-8"></script>

</body>
</html>