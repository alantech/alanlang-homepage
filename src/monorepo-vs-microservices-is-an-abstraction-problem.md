# Monorepo vs Microservices is an Abstraction Problem

**16 August 2021 | Luis F. De Pombo, Alejandro Guillen, Colton Donnelly, David Ellis**

Like Vim vs Emacs, Static vs Dynamic Languages, and Tabs vs Spaces, it seems like a Monorepo vs Microservices will forever be debated by software engineers, with both sides having valid points and the choice ending up more due to personal preference than anything else. The cycle of point and counterpoint often looks like:

1. Everyone starts with a monorepo, as you always start with a singular codebase to work with, and the complexity is still small overall. Likely a simple horizontally-scaled application layer on top of a vertically-scaled database layer.
2. Compute heavy tasks start to negatively impact the response times of database-bound requests. The first potential monorepo vs microservice debate can happen here, as a separately deployed service for compute heavy jobs can make use of a language or framework that is designed for such tasks, but often the existing language has some option for background task running, and rewriting this code would distract from other work that can be done, so using the background task library and deploying both application clusters from the same repo wins out.
3. Latency-sensitive endpoints start impacting the architecture of the application layer. If the latency-sensitive piece is mostly read-bound, a cache layer is added either above the latency-sensitive endpoint, or between the application layer and the database layer, or both. If the latency-sensitive piece is write-bound, scaling up the database layer is often the first tack taken. If the latency-sensitive piece is both read-and-write bound in a kind of state machine way, either pushing this logic to the client-side or bolting on a second database (often NoSQL) dedicated to this small part of the application logic is done. This is the second point where breaking out into microservices may be debated, as the additional complexity in the request-handling for these endpoints can negatively impact development velocity on the "regular" endpoints as there may be extra "ceremony" to endpoint development that most of the developers do not care about and potentially don't fully understand, especially if homegrown with ill-defined terminology and separation-of-concerns.
4. Testing and deployment times continue to rise for monorepos. Only certain developers are trusted with managing a release as it has become complicated with many different things to monitor simultaneously and this monitoring process constantly in flux as new features are added. Developers trying to add one new feature into the monorepo are hit with very long iteration cycles as the test suite takes a very long time to complete and local testing has possibly stopped working because no one was officially in charge of it and getting high priority features and showstopping bugs fixed in production took precedence. Breaking up the monorepo to make test and deploy cycles shorter is brought up by those in favor of microservices, while proponents of the monorepo argue that improving test and making individual subsystems separately deployable avoids the complexities of multiple repos.

At this point, it often devolves into a point and counterpoint between the two parties. The proponents of microservices arguing that separately deployable and testable code is already essentially microservices, but by being in the same repo, code changes that are impossible to migrate to but pass tests are possible. Eg, services A and B are both changed simultaneously to A' and B' and the test suite passes, but if you deploy service A -> A' first, it cannot interact with service B, and if you deploy B' first, it cannot interact with A, and since you can't deploy both services absolutely simultaneously, you're now going to cause a temporary outage. The proponents of monorepo argue that you can enforce that service mocks in the test suite cannot be changed at the same time code in the service is changed, so you can have the test suite enforce that the new code can talk to the old services and force the consideration of the migration path.

Or perhaps it came down to different teams needing differing versions of a vendored library, with the microservices side arguing improved development velocity when the scope of impact for their team's needs isn't the entire company, and the monorepo side arguing that there may be unexpected interactions between differing versions of the same library, or difficulty performing security analysis, etc, and the microservices side counter-argues that proper schema enforcement would prevent the interaction issue and a simple for loop wrapping the security scanner handing it each service repo in the git server would solve the latter, etc.

Whatever the reasoning, the two camps both make solid arguments and have solid technical solutions for either approach, and the choice for one or the other tends to follow a balance of the past decisions and current preferences of the "key" members of the engineering team that can convince most of the other engineers and management above them to take one path or the other.

But is this actually the case? Let's take a look at the vendored library example more closely. Some of you saw that example and accepted it without question, while others of you were probably completely unfamiliar with it. For those of you coming from a C/C++ background, where each project must define their own way to vendor third party libraries because the build toolchain doesn't even consider the possibility, you likely saw this as a policy decision in the engineering org and the microservice proponents intentionally ignoring the alternative of allowing per-project vendored libraries within the monorepo. If you came from a Python or Java background, you likely saw this as entirely a technical issue, as dependencies are a list and you *can't* vendor multiple versions of the same library without jumping through hoops of `$PATH` munging or library name rewriting (and rewriting invocations in all other code using the version with the rewritten name). And if you came from a Node.js background you didn't understand it at all because your singular project probably has multiple versions of [ajv](https://www.npmjs.com/package/ajv) in your dependency tree and you don't even know *why*.

Dependency version conflict is or is not an issue for large-scale monorepos depending on the particular abstraction the programming language used in the monorepo chose for third party libraries. No abstraction leaves the decision up to the team, but also gives the team more work (both real and bikeshedding), while the wrong abstraction forces your hand on your software organization.

<!-- Should the following paragraph be included, or is it beating on the same subject too much?

A few of you may have also taken issue with the testing and deployment times affecting productivity negatively. Either you have not yet worked on a truly massive team with a massive number of changes per day, or you had an incredibly experienced software architect in charge of your company's codebase to avoid all of the pitfalls. (Eg, making sure that the test suite runs in parallel, can be easily scoped to a small subset of the codebase, preferably automatically based on the changed files, and the CI system considers local testing *itself* a test to run, spinning up the company-standard local environment and then running the test suite in that, instead of a specialized environment for the CI system.) 
-->

We believe that all of the problems that causes one to migrate from a monorepo to microservices are due to problems in the abstractions of the languages used to write backend production code, that a new language can resolve these abstractions, and that a new language is *required* for some of these abstraction issues as the foundation of these languages does not fit with the reality they operate in. 
